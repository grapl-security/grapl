# Environment file used by our Docker Compose local environment /
# integration / end-to-end testing setup.

# Ports
########################################################################

# Dgraph default ports
# https://dgraph.io/docs/deploy/ports-usage/
DGRAPH_ALPHA_GRPC_EXTERNAL_PUBLIC_PORT=9080
DGRAPH_ALPHA_HTTP_EXTERNAL_PUBLIC_PORT=8080
DGRAPH_RATEL_HTTP_EXTERNAL_PUBLIC_PORT=8000
DGRAPH_ZERO_GRPC_PRIVATE_PORT=5080

# Localstack's edge port; all Localstack services are proxied through
# this port.
LOCALSTACK_PORT=4566 # default value

# DynamoDB Local port
DYNAMODB_PORT=${LOCALSTACK_PORT}

# Grapl Ports!
GRAPL_AUTH_PORT=8900
GRAPL_DGRAPH_TTL_PORT=8124
GRAPL_GRAPHQL_PORT=5000
GRAPL_MODEL_PLUGIN_DEPLOYER_PORT=8123
GRAPL_NOTEBOOK_PORT=8888
GRAPL_UX_ROUTER_PORT=8901

# Redis default port
REDIS_PORT=6379

# MinIO default port.
#
# While localstack does have an S3 implementation, we've noted some
# test failures using it. Until we fully understand the nature of that
# failure, we will continue using MinIO as our S3 substitute.
S3_PORT_INTERNAL=9000 # default value
S3_PORT_EXTERNAL=${S3_PORT_INTERNAL}

# Localstack Secretsmanager
SECRETSMANAGER_PORT=${LOCALSTACK_PORT}

# TODO: This may be a different port for different services
VSC_DEBUGGER=8401

# Local-only "signaling" port
#
# We'll often start up a simple HTTP server with
#
#     python -m http.server
#
# to use as a signaling mechanism between containers
# using `wait-for-it`... this is the port we'll use.
WAIT_PORT=1337


# Hosts
#
# We use Docker network aliases to set these up, and then ultimately
# pass them into our services.
########################################################################
AWS_REGION=us-east-1

LOCALSTACK_HOST=aws.grapl.test
DGRAPH_HOST=dgraph.grapl.test
GRAPL_API_HOST=api.grapl.test
REDIS_HOST=redis.grapl.test
S3_HOST=s3.${AWS_REGION}.amazonaws.com

# Lambda "Hosts"
########################################################################
# These are currently presented as services in local grapl, but
# they're really lambda functions... when we can run them as lambdas
# locally, these host names should probably go away.
GRAPL_AUTH_HOST=auth.grapl.test
GRAPL_MODEL_PLUGIN_DEPLOYER_HOST=model-plugin-deployer.grapl.test
GRAPL_GRAPHQL_HOST=graphql.grapl.test
GRAPL_UX_ROUTER_HOST=ux-router.grapl.test

# Endpoints
#
# NOTE: Endpoints have a protocol and port. Additionally, they are
# only for usage within the Docker Compose network.
########################################################################

REDIS_ENDPOINT=http://${REDIS_HOST}:${REDIS_PORT}
S3_ENDPOINT=http://${S3_HOST}:${S3_PORT_INTERNAL}

# The remaining endpoints are all just aliases for our unified
# Localstack service
LOCALSTACK_ENDPOINT=http://${LOCALSTACK_HOST}:${LOCALSTACK_PORT}
DYNAMODB_ENDPOINT=${LOCALSTACK_ENDPOINT}
SQS_ENDPOINT=${LOCALSTACK_ENDPOINT}
SECRETSMANAGER_ENDPOINT=${LOCALSTACK_ENDPOINT}

# Credentials
########################################################################
FAKE_AWS_ACCESS_KEY_ID="THIS_IS_A_FAKE_AWS_ACCESS_KEY_ID"
FAKE_AWS_SECRET_ACCESS_KEY="THIS_IS_A_FAKE_AWS_SECRET_ACCESS_KEY"

DYNAMODB_ACCESS_KEY_ID="${FAKE_AWS_ACCESS_KEY_ID}"
DYNAMODB_ACCESS_KEY_SECRET="${FAKE_AWS_SECRET_ACCESS_KEY}"
SECRETSMANAGER_ACCESS_KEY_ID="${FAKE_AWS_ACCESS_KEY_ID}"
SECRETSMANAGER_ACCESS_KEY_SECRET="${FAKE_AWS_SECRET_ACCESS_KEY}"
SQS_ACCESS_KEY_ID="${FAKE_AWS_ACCESS_KEY_ID}"
SQS_ACCESS_KEY_SECRET="${FAKE_AWS_SECRET_ACCESS_KEY}"
S3_ACCESS_KEY_ID="${FAKE_AWS_ACCESS_KEY_ID}"
S3_ACCESS_KEY_SECRET="${FAKE_AWS_SECRET_ACCESS_KEY}"

# Logging
########################################################################
GRAPL_LOG_LEVEL=DEBUG
# Python buffers output by default, which means it can swallow
# information that we might like to actually see in our container
# logs. This turns that buffering off.
PYTHONUNBUFFERED=1
RUST_BACKTRACE=1
RUST_LOG=ERROR

# Miscellaneous
########################################################################
MG_ALPHAS=${DGRAPH_HOST}:${DGRAPH_ALPHA_GRPC_EXTERNAL_PUBLIC_PORT}
BUCKET_PREFIX=local-grapl
