# Rather than simply using *truly* empty target files, we'll add a
# message to ours to provide pointers for people that may not be
# familiar with this concept.
define empty_target_message
This is an "empty target" file; see
https://www.gnu.org/software/make/manual/html_node/Empty-Targets.html.

It is generated by the "$@" target in

	$(CURDIR)/$(lastword $(MAKEFILE_LIST))

Please consult that target that for additional context.
endef
# This must be exported as a *shell* variable, rather than used as a
# *make* variable, in order for us to be able to properly echo this
# multiline string to the files.
#
# Every such target should include
#
#    @echo "$${empty_target_message}" > $@
#
# as its final command.
export empty_target_message

# Pull the version from our rust-toolchain.toml file; automatic
# synchronization FTW!
# TODO: Consider pulling this logic into a script for other uses
rust_version := $(shell grep channel rust-toolchain.toml | sed -E 's/channel = "(.*)"/\1/g')

.ONESHELL:
SHELL := bash
.SHELLFLAGS := -o errexit -o nounset -o pipefail -c

build_image_tag := grapl-rust-build-env:latest
docker_run := REPO_ROOT="$(abspath $(CURDIR)/../..)" IMAGE=$(build_image_tag) ./bin/run_in_container.sh

.PHONY: clean-all
clean-all: clean-image
clean-all: clean-volumes

########################################################################

.PHONY: clean-image
clean-image: ## Remove the build environment image
	docker rmi --force "${build_image_tag}" 2> /dev/null
	rm -f image

########################################################################
# Clean all volumes

# TODO: keep these names in sync with what the `docker run` invocation uses.
volumes := grapl-cargo-cache grapl-rustup grapl-target

.PHONY: clean-volumes
clean-volumes: ## Remove all volumes used by our build environment container

define make-clean-volume-rule
clean-volumes: clean-volume-$1

.PHONY: clean-volume-$1
clean-volume-$1: ## Remove the $1 volume
	docker volume remove --force $1
endef

$(foreach volume,${volumes},$(eval $(call make-clean-volume-rule,$(volume))))

########################################################################

format: ## Format all code
	bin/format --update

########################################################################

lint-rustfmt: ## Check formatting
	bin/format --check

.PHONY: lint-clippy
lint-clippy: image
lint-clippy: ## Run Clippy
	$(docker_run) bin/lint

.PHONY: cargo-udeps
cargo-udeps: image
cargo-udeps: # Run cargo-udeps
	$(docker_run) bin/udeps

########################################################################

image: build-env.Dockerfile
image: rust-toolchain.toml
image: ## Build the build environment image
	docker buildx build \
		--build-arg=RUST_VERSION="${rust_version}" \
		--file=build-env.Dockerfile \
		--tag="${build_image_tag}" \
		.
		@echo "$${empty_target_message}" > $@

.PHONY: build
build: image
build: ## Build Rust code
	$(docker_run) cargo build

.PHONY: test
test: image
test: ## Run `cargo test`, without generating test coverage statistics
	$(docker_run) cargo test

.PHONY: coverage
coverage: image
coverage: ## Run `cargo tarpaulin` to generate test coverage statistics.
# NOTE: This invocation requires that `<REPO_ROOT>/dist` be mounted
# into the container. This is handled in `run_in_container.sh`; just
# be aware of this little wrinkle.
	$(docker_run) cargo install cargo-tarpaulin
	$(docker_run) cargo tarpaulin \
		--out=Xml \
		--output-dir=/dist/coverage

.PHONY: shell
shell: image
shell: ## Enter a shell in our build container to aid in debugging
	$(docker_run) bash
