use bytes::{
    Bytes,
    BytesMut,
};
use prost::Message;

use crate::{
    graplinc::common::v1beta1::{
        SystemTime,
        Uuid,
    },
    protobufs::graplinc::grapl::api::pipeline_ingress::v1beta1::{
        PublishRawLogRequest as PublishRawLogRequestProto,
        PublishRawLogResponse as PublishRawLogResponseProto,
    },
    type_url,
    SerDe,
    SerDeError,
};

//
// PublishRawLogRequest
//

#[derive(Debug, Clone, PartialEq)]
pub struct PublishRawLogRequest {
    pub event_source_id: Uuid,
    pub tenant_id: Uuid,
    pub log_event: Bytes,
}

impl TryFrom<PublishRawLogRequestProto> for PublishRawLogRequest {
    type Error = SerDeError;

    fn try_from(request_proto: PublishRawLogRequestProto) -> Result<Self, Self::Error> {
        let event_source_id = request_proto
            .event_source_id
            .ok_or(SerDeError::MissingField("event_source_id"))?;

        let tenant_id = request_proto
            .tenant_id
            .ok_or(SerDeError::MissingField("tenant_id"))?;

        Ok(PublishRawLogRequest {
            event_source_id: event_source_id.into(),
            tenant_id: tenant_id.into(),
            log_event: Bytes::from(request_proto.log_event),
        })
    }
}

impl From<PublishRawLogRequest> for PublishRawLogRequestProto {
    fn from(request: PublishRawLogRequest) -> Self {
        PublishRawLogRequestProto {
            event_source_id: Some(request.event_source_id.into()),
            tenant_id: Some(request.tenant_id.into()),
            log_event: request.log_event.to_vec(),
        }
    }
}

impl type_url::TypeUrl for PublishRawLogRequest {
    const TYPE_URL: &'static str =
        "graplsecurity.com/graplinc.grapl.api.pipeline_ingress.v1beta1.PublishRawLogRequest";
}

impl SerDe for PublishRawLogRequest {
    fn serialize(self) -> Result<Bytes, SerDeError> {
        let request_proto = PublishRawLogRequestProto::from(self);
        let mut buf = BytesMut::with_capacity(request_proto.encoded_len());
        request_proto.encode(&mut buf)?;
        Ok(buf.freeze())
    }

    fn deserialize<B>(buf: B) -> Result<Self, SerDeError>
    where
        B: bytes::Buf,
        Self: Sized,
    {
        let request_proto: PublishRawLogRequestProto = Message::decode(buf)?;
        request_proto.try_into()
    }
}

//
// PublishRawLogResponse
//

#[derive(Debug, Clone, PartialEq)]
pub struct PublishRawLogResponse {
    pub created_time: SystemTime,
}

impl PublishRawLogResponse {
    /// build a response with created_time set to SystemTime::now()
    pub fn ok() -> Self {
        PublishRawLogResponse {
            created_time: SystemTime::now()
        }
    }
}

impl TryFrom<PublishRawLogResponseProto> for PublishRawLogResponse {
    type Error = SerDeError;

    fn try_from(response_proto: PublishRawLogResponseProto) -> Result<Self, Self::Error> {
        let created_time = response_proto
            .created_time
            .ok_or(SerDeError::MissingField("created_time"))?;

        Ok(PublishRawLogResponse {
            created_time: created_time.try_into()?,
        })
    }
}

impl TryFrom<PublishRawLogResponse> for PublishRawLogResponseProto {
    type Error = SerDeError;

    fn try_from(response: PublishRawLogResponse) -> Result<Self, Self::Error> {
        Ok(PublishRawLogResponseProto {
            created_time: Some(response.created_time.try_into()?),
        })
    }
}

impl type_url::TypeUrl for PublishRawLogResponse {
    const TYPE_URL: &'static str =
        "grapsecurity.com/graplinc.grapl.api.pipeline_ingress.v1beta1.PublishRawLogResponse";
}

impl SerDe for PublishRawLogResponse {
    fn serialize(self) -> Result<Bytes, SerDeError> {
        let response_proto = PublishRawLogResponseProto::try_from(self)?;
        let mut buf = BytesMut::with_capacity(response_proto.encoded_len());
        response_proto.encode(&mut buf)?;
        Ok(buf.freeze())
    }

    fn deserialize<B>(buf: B) -> Result<Self, SerDeError>
    where
        B: bytes::Buf,
        Self: Sized,
    {
        let response_proto: PublishRawLogResponseProto = Message::decode(buf)?;
        response_proto.try_into()
    }
}

//
// client
//

/// This module contains the gRPC client for the pipeline ingress API. We
/// encapsulate all the types generated by the protocol buffer compiler and
/// instead expose our own "sanitized" version of the API.
pub mod client {
    use crate::{
        graplinc::grapl::api::pipeline_ingress::v1beta1::{
            PublishRawLogRequest,
            PublishRawLogResponse,
        },
        protobufs::graplinc::grapl::api::pipeline_ingress::v1beta1::pipeline_ingress_service_client::PipelineIngressServiceClient as PipelineIngressServiceClientProto,
        SerDeError,
    };

    use futures::FutureExt;
    use thiserror::Error;
    use tonic::Request;

    #[non_exhaustive]
    #[derive(Debug, Error)]
    pub enum ConfigurationError {
        #[error("failed to connect {0}")]
        ConnectionError(#[from] tonic::transport::Error)
    }

    #[non_exhaustive]
    #[derive(Debug, Error)]
    pub enum PipelineIngressApiError {
        #[error("failed to serialize/deserialize {0}")]
        SerDeError(#[from] SerDeError),

        #[error("received unfavorable gRPC status {0}")]
        GrpcStatus(#[from] tonic::Status),
    }

    pub struct PipelineIngressClient {
        proto_client: PipelineIngressServiceClientProto<tonic::transport::Channel>
    }

    impl PipelineIngressClient {
        pub async fn connect<T>(endpoint: T) -> Result<Self, ConfigurationError>
        where
            T: std::convert::TryInto<tonic::transport::Endpoint>,
            T::Error: std::error::Error + Send + Sync + 'static
        {
            Ok(PipelineIngressClient {
                proto_client: PipelineIngressServiceClientProto::connect(endpoint).await?,
            })
        }

        pub async fn publish_raw_log(
            &mut self, raw_log: PublishRawLogRequest
        ) -> Result<PublishRawLogResponse, PipelineIngressApiError> {
            Ok(self.proto_client.publish_raw_log(Request::new(raw_log.into()))
                .map(|response| -> Result<PublishRawLogResponse, PipelineIngressApiError> {
                    let inner = response?.into_inner();
                    Ok(inner.try_into()?)
                })
                .await?)
        }
    }
}

//
// server
//

/// This module contains the gRPC server for serving the pipeline ingress
/// API. We encapsulate all the types generated by the protocol buffer compiler
/// and instead expose our own "sanitized" version of the API. Users should
/// implement their business logic by constructing an object conforming to the
/// PipelineIngressApi trait. To run the gRPC server implementing that business
/// logic, inject the PipelineIngressApi implementation into the
/// PipelineIngressServer's constructor.
pub mod server {
    use std::{
        net::SocketAddr,
        marker::PhantomData
    };

    use crate::{
        graplinc::grapl::api::pipeline_ingress::v1beta1::{
            PublishRawLogRequest,
            PublishRawLogResponse,
        },
        protobufs::graplinc::grapl::api::pipeline_ingress::v1beta1::{
            pipeline_ingress_service_server::{
                PipelineIngressService as PipelineIngressServiceProto,
                PipelineIngressServiceServer as PipelineIngressServiceServerProto
            },
            PublishRawLogRequest as PublishRawLogRequestProto,
            PublishRawLogResponse as PublishRawLogResponseProto,
        },
    };
    use futures::{
        channel::oneshot::{
            Sender,
            Receiver,
            self
        },
        FutureExt,
        TryFutureExt,
    };
    use thiserror::Error;
    use tonic::{
        Request,
        Response,
        Status,
        transport::Server,
    };

    //
    // protocol buffer stuff
    //

    /// This struct implements the internal gRPC representation of the pipeline
    /// ingress server. We've implemented the service trait generated by tonic
    /// in such a way that it delegates to an externally supplied
    /// PipelineIngressApi. This way all the protocol buffer compiler generated
    /// types are encapsulated, and the public API is implemented in terms of
    /// this crate's sanitized types.
    struct PipelineIngressProto<T, E>
    where
        T: PipelineIngressApi<E>,
        E: ToString + 'static
    {
        api_server: T,
        _e: PhantomData<E>
    }

    impl <T, E> PipelineIngressProto<T, E>
    where
        T: PipelineIngressApi<E>,
        E: ToString + 'static
    {
        fn new(api_server: T) -> Self {
            PipelineIngressProto {
                api_server,
                _e: PhantomData
            }
        }
    }

    #[tonic::async_trait]
    impl <T, E> PipelineIngressServiceProto for PipelineIngressProto<T, E>
    where
        T: PipelineIngressApi<E> + Send + Sync + 'static,
        E: ToString + Send + Sync + 'static
    {
        async fn publish_raw_log(
            &self,
            request: Request<PublishRawLogRequestProto>
        ) -> Result<Response<PublishRawLogResponseProto>, Status> {
            let inner_request: PublishRawLogRequest = match request.into_inner().try_into() {
                Ok(request) => request,
                Err(e) => return Err(Status::unknown(e.to_string())),
            };

            let response = self.api_server
                .publish_raw_log(inner_request)
                .map_err(|e| Status::unknown(e.to_string()))
                .await?;

            let response: PublishRawLogResponseProto = match response.try_into() {
                Ok(res) => res,
                Err(e) => return Err(Status::unknown(e.to_string())),
            };

            Ok(Response::new(response))
        }
    }

    //
    // public API
    //

    /// Implement this trait to define the pipeline ingress API's business logic
    #[tonic::async_trait]
    pub trait PipelineIngressApi<E>
    where
        E: ToString + 'static
    {
        async fn publish_raw_log(
            &self, request: PublishRawLogRequest
        ) -> Result<PublishRawLogResponse, E>;
    }

    #[non_exhaustive]
    #[derive(Debug, Error)]
    pub enum ConfigurationError {
        #[error("encountered tonic error {0}")]
        TonicError(#[from] tonic::transport::Error),
    }

    /// The pipeline-ingress server serves the pipeline-ingress API
    pub struct PipelineIngressServer<T, E>
    where
        T: PipelineIngressApi<E> + Send + Sync + 'static,
        E: ToString + Send + Sync + 'static
    {
        api_server: T,
        addr: SocketAddr,
        shutdown_rx: Receiver<()>,
        e_: PhantomData<E>,
    }

    impl <T, E> PipelineIngressServer<T, E>
    where
        T: PipelineIngressApi<E> + Send + Sync + 'static,
        E: ToString + Send + Sync + 'static
    {
        /// Construct a new gRPC server which will serve the given API
        /// implementation on the given socket address. Server is constructed in
        /// a non-running state. Call the serve() method to run the server. This
        /// method also returns a channel you can use to trigger server
        /// shutdown.
        pub fn new(api_server: T, addr: SocketAddr) -> (Self, Sender<()>) {
            let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();
            (PipelineIngressServer {
                api_server,
                addr,
                shutdown_rx,
                e_: PhantomData
            }, shutdown_tx)
        }

        /// Run the gRPC server and serve the API on this server's socket
        /// address. Returns a ConfigurationError if the gRPC server cannot run.
        pub async fn serve(self) -> Result<(), ConfigurationError> {
            // TODO: add logging interceptor, tls_config, concurrency limits
            Ok(Server::builder()
               .add_service(PipelineIngressServiceServerProto::new(
                   PipelineIngressProto::new(self.api_server)
               ))
               .serve_with_shutdown(self.addr, self.shutdown_rx.map(|_| ()))
               .await?)
        }
    }
}
