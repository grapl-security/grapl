.DEFAULT_GOAL := build-code

# Rather than simply using *truly* empty target files, we'll add a
# message to ours to provide pointers for people that may not be
# familiar with this concept.
define empty_target_message
This is an "empty target" file; see
https://www.gnu.org/software/make/manual/html_node/Empty-Targets.html.

It is generated by the "$@" target in

	$(CURDIR)/$(lastword $(MAKEFILE_LIST))

Please consult that target that for additional context.
endef
# This must be exported as a *shell* variable, rather than used as a
# *make* variable, in order for us to be able to properly echo this
# multiline string to the files.
#
# Every such target should include
#
#    @echo "$${empty_target_message}" > $@
#
# as its final command.
export empty_target_message

build_image_tag := grapl-engagement-view-build-env:latest

# Additional arguments to pass to `docker run` before the image
# name. This can be modified on a target-by-target basis as needed.
extra_docker_run_args =

# NOTE: This **must** be `=` and not `:=` because we want to reserve
# the ability to inject additional Docker arguments on a
# target-by-target basis
DOCKER_RUN = docker run \
		--rm \
		--user="$(shell id --user):$(shell id --group)" \
		--workdir=/engagement_view \
		--env=HOME=/engagement_view \
		--mount=type=bind,source="$(shell pwd)",target=/engagement_view \
		--mount=type=volume,source=grapl-engagement-view-yarn,target=/engagement_view/.yarn/state \
		--mount=type=volume,source=grapl-engagement-view-node-modules,target=/engagement_view/node_modules \
		$(extra_docker_run_args) \
		-- \
		$(build_image_tag)

# Changes to any of these files will trigger a rebuild of the code
FILES := $(shell find src -type f) $(shell find public -type f) componentMap/components.txt tsconfig.json

build-image: build-env.Dockerfile
build-image: ## Build the build image if necessary
	docker buildx build \
		--file=build-env.Dockerfile \
		--tag=$(build_image_tag) \
		.
	@echo "$${empty_target_message}" > $@

# ----------------------------------------------------------------------

# These directories are the ones we'll back with Docker volumes. They
# must exist on the workstation already or else they'll end up being
# created with root ownership, which complicates cleanup. These should
# be included as order-only prerequisites for any targets that use the
# $(DOCKER_RUN) macro.

volume_dirs := .yarn/state node_modules

$(volume_dirs):
	mkdir -p $@

# ----------------------------------------------------------------------
regenerate-lockfile: build-image package.json yarn.lock
regenerate-lockfile: | $(volume_dirs)
regenerate-lockfile: ## Regenerate the yarn.lock
	$(DOCKER_RUN) yarn install --mode=update-lockfile

install-dependencies: build-image package.json yarn.lock
install-dependencies: | $(volume_dirs)
install-dependencies: ## Install dependencies in the build container if necessary
	$(DOCKER_RUN) yarn install --immutable
	@echo "$${empty_target_message}" > $@

# Not named `build` because a directory of that name gets generated
# during the build process
build-code: install-dependencies $(FILES)
build-code: ## Build the code if any files have changed
	$(DOCKER_RUN) yarn build
	$(DOCKER_RUN) yarn analyze-build
	@echo "$${empty_target_message}" > $@

# Note that `run-tests` is a phony target, so it will run each time it
# is invoked, whether code has changed or not.
.PHONY: run-tests
run-tests: build-code
run-tests: ## Run all unit tests and gather coverage statistics
	$(DOCKER_RUN) yarn test \
		--coverage \
		--watchAll=false \
		--coverageDirectory=/engagement_view/coverage/

.PHONY: shell
shell: extra_docker_run_args := --interactive --tty
shell: build-image
shell: ## Drop into a shell inside the build container
	$(DOCKER_RUN) bash

.PHONY: start
start: extra_docker_run_args := --interactive --tty --network host
start: build-image
start: # Yarn React development server
	$(DOCKER_RUN) yarn start

# Clean
########################################################################

.PHONY: clean
clean: clean-image
clean: clean-volumes
clean: clean-files
clean: ## Remove all generated state and artifacts

.PHONY: clean-image
clean-image: ## Remove the build image
	docker rmi --force "$(build_image_tag)" 2> /dev/null
	rm -f build-image

.PHONY: clean-volumes
clean-volumes: ## Remove all Docker volumes

define make-clean-volume-rule
clean-volumes: clean-volume-$1

.PHONY: clean-volume-$1
clean-volume-$1: ## Remove the $1 volume
	docker volume remove --force $1
	rm -f install-dependencies
	rm -f build-code
endef
volumes = grapl-engagement-view-node-modules grapl-engagement-view-yarn
$(foreach volume,${volumes},$(eval $(call make-clean-volume-rule,$(volume))))

.PHONY: clean-files
clean-files: ## Remove all additional generated files and directories
	rm -f .bash_history
	rm -Rf build
	rm -Rf .cache
	rm -Rf coverage
	rm -Rf .node
	rm -Rf node_modules
	rm -Rf .npm
	rm -Rf .yarn
