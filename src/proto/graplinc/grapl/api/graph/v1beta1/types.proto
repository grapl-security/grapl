syntax = "proto3";

import "google/protobuf/wrappers.proto";

package graplinc.grapl.api.graph.v1beta1;

// The Session Identity Strategy is used to derive a canonical identity for any node that has a
// 'pseudo key', as well as a beginning, middle, and end.
// The 'pseudo key' can itself be multiple values concatenated together.
// As an example, a ProcessNode would have a pseudo key based on its hostname and pid,
// but because that combination is only unique while the process is alive, we also take into account
// the creation time of that process, when we've last seen it, and when it's terminated.
message Session {
    // Such as the pid + assetid
    repeated string primary_key_properties = 1;
    bool primary_key_requires_asset_id = 2;
    uint64 create_time = 3;
    uint64 last_seen_time = 4;
    uint64 terminate_time = 5;
    repeated string negation_keys = 6;
    repeated string optional_static_keys = 7;
    repeated string drop_after_identification = 8;
}

// The Static Identity Strategy is used when a node already has its own way of being uniquely identified.
// As one example, an AWS Resource Name uniquely identifies all AWS resources across accounts, so it would be
// a suitable Static identity.
message Static {
    repeated string primary_key_properties = 1;
    bool primary_key_requires_asset_id = 2;
}

message IdStrategy {
    oneof strategy {
        Session session = 1;
        Static static = 2;
    }
}



message IncrementOnlyUintProp {
    uint64 prop = 1;
}

message ImmutableUintProp {
    uint64 prop = 1;
}

message DecrementOnlyUintProp {
    uint64 prop = 1;
}

message DecrementOnlyIntProp {
    int64 prop = 1;
}

message IncrementOnlyIntProp {
    int64 prop = 1;
}

message ImmutableIntProp {
    int64 prop = 1;
}

message ImmutableStrProp {
    string prop = 1;
}

// NodeProperty not only denotes what primitive type the value should be treated as - such as u64, i64, string,
// but also the behavior of property merges. Because Grapl can not expect any kind of strict ordering of events
// within or across datasources every property has to define a merge function to resolve conflicts.
// *In general* these merges are idempotent and commutative, but not necessarily - for example, a string
// that gets set to the "first" value and then never changes is not commutative. This is actually OK, so long as  we
// have external knowledge of the datasources that informs us that the string will never change.
message NodeProperty {
    oneof property {
        // `increment_only_uint_prop` is an unsigned 64bit integer. On merge the larger value is stored.
        IncrementOnlyUintProp increment_only_uint = 1;
        // `decrement_only_uint_prop` is an unsigned 64bit integer. On merge the smaller value is stored.
        DecrementOnlyUintProp decrement_only_uint = 2;
        // `immutable_uint_prop` is an unsigned 64bit integer. On merge the old value is preserved.
        ImmutableUintProp immutable_uint = 3;
        // `increment_only_int_prop` is a signed 64bit integer. On merge the larger value is stored.
        IncrementOnlyIntProp increment_only_int = 4;
        // `decrement_only_int_prop` is a signed 64bit integer. On merge the smaller value is stored.
        DecrementOnlyIntProp decrement_only_int = 5;
        // `immutable_int_prop` is a signed 64bit integer. On merge the old value is preserved.
        ImmutableIntProp immutable_int = 6;
        // `immutable_int_prop` is a utf8 encoded string. On merge the old value is preserved.
        ImmutableStrProp immutable_str = 7;
    }
}

// A 'NodeDescription' is not a canonical, identified node. It describes, based on some data, a node
// that may or may not yet exist. For example, if we parse a log we may have information about a Process,
// - we don't know which Process in the graph that is, but we have information about it; we can describe it.
message NodeDescription {
    // The predicates for a given node, as they existed at that time
    map<string, NodeProperty> properties = 1;
    // The node_key, though at this point it may not be a canonical identity
    string node_key = 2;
    // The type of the node, as a string
    string node_type = 3;
    // The strategy to use for identifying this node. While we currently can store multiple strategies,
    // currently only strategy one is supported.
    repeated IdStrategy id_strategy = 4;
}

// Identified nodes are similar to a 'NodeDescription', except that their node_key is
// canonical.
message IdentifiedNode {
    map<string, NodeProperty> properties = 1;
    string node_key = 2;
    string node_type = 3;
}

// A MergedNode represents a node that has already been merged into Grapl.
message MergedNode {
    map<string, NodeProperty> properties = 1;
    // The 'uid' represents the DGraph node uid
    uint64 uid = 2;
    string node_key = 3;
    string node_type = 4;
}

// Represents a directed edge between two nodes. The node_key's may be canonical, or they may not be,
// depending on the pipeline stage
message Edge {
    // The node_key associated with the 'source' of the edge
    string from_node_key = 1;
    // The node_key associated with the 'destination' of the edge
    string to_node_key  = 2;
    // The name of the edge
    string edgeName = 3;
}

// Represents a directed edge between two nodes, where both nodes, and this edge, exist in the graph.
message MergedEdge {
    // The uid associated with the 'source' of the edge
    string from_uid = 1;
    // The node_key associated with the 'source' of the edge
    string from_node_key = 2;
    // The uid associated with the 'destination' of the edge
    string to_uid = 3;
    // The node_key associated with the 'destination' of the edge
    string to_node_key = 4;
    // The name of the edge
    string edgeName = 5;
}

// Represents multiple edges - mostly necessary because protobuf can't express a `map` of `repeated` values directly.
message EdgeList {
    repeated Edge edges = 1;
}

// Represents multiple edges - mostly necessary because protobuf can't express a `map` of `repeated` values directly.
// Every edge in the MergedEdgeList has been merged into the graph store.
message MergedEdgeList {
    repeated MergedEdge edges = 1;
}

// GraphDescription represents a graph of nodes that may or may not exist yet in the graph store.
// These nodes may or may not have canonical identities.
message GraphDescription {
    map <string, NodeDescription> nodes = 1;
    map <string, EdgeList> edges = 2;
}

// GraphDescription represents a graph of nodes that may or may not exist yet in the graph store.
// These nodes have canonical identities.
message IdentifiedGraph{
    map <string, IdentifiedNode> nodes = 1;
    map <string, EdgeList> edges = 2;
}

// GraphDescription represents a graph of nodes that exist in the graph store. These nodes
// have canonical identities.
message MergedGraph{
    map <string, MergedNode> nodes = 1;
    map <string, MergedEdgeList> edges = 2;
}
