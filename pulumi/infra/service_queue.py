import json
from typing import NamedTuple, Optional

import pulumi_aws as aws
from infra import queue_policy
from infra.config import DEPLOYMENT_NAME
from infra.emitter import EventEmitter

import pulumi


class ServiceQueueNames(NamedTuple):
    service_name: str
    queue: str
    retry_queue: str
    dead_letter_queue: str


class ServiceQueue(pulumi.ComponentResource):
    """
    Each service currently deals with three queues. The main queue
    falls back to a "retry queue", which itself falls back to a "dead
    letter" queue.
    """

    def __init__(
        self, name: str, opts: Optional[pulumi.ResourceOptions] = None
    ) -> None:
        super().__init__("grapl:ServiceQueue", name, None, opts)

        message_retention_seconds = 60 * 60 * 24 * 4  # 4 days

        # `arn` is the ARN of a queue. This is a function because of
        # the need to use Output.apply on the ARN.
        def redrive_policy(arn: pulumi.Output) -> str:
            return json.dumps(
                {
                    "deadLetterTargetArn": arn,
                    "maxReceiveCount": 3,
                }
            )

        # TODO: delete_before_replace is only needed if we're
        # overriding the name of the queues

        logical_dead_letter_name = f"{name}-dead-letter-queue"
        physical_dead_letter_name = f"{DEPLOYMENT_NAME}-{logical_dead_letter_name}"
        self.dead_letter_queue = aws.sqs.Queue(
            logical_dead_letter_name,
            name=physical_dead_letter_name,
            message_retention_seconds=message_retention_seconds,
            visibility_timeout_seconds=30,
            opts=pulumi.ResourceOptions(
                parent=self,
                delete_before_replace=True,
            ),
        )
        pulumi.export(logical_dead_letter_name, self.dead_letter_queue.id)

        logical_retry_name = f"{name}-retry-queue"
        physical_retry_name = f"{DEPLOYMENT_NAME}-{logical_retry_name}"
        self.retry_queue = aws.sqs.Queue(
            logical_retry_name,
            name=physical_retry_name,
            message_retention_seconds=message_retention_seconds,
            visibility_timeout_seconds=360,
            redrive_policy=self.dead_letter_queue.arn.apply(redrive_policy),
            opts=pulumi.ResourceOptions(
                parent=self,
                delete_before_replace=True,
            ),
        )
        pulumi.export(logical_retry_name, self.retry_queue.id)

        logical_queue_name = f"{name}-queue"
        physical_queue_name = f"{DEPLOYMENT_NAME}-{logical_queue_name}"
        self.queue = aws.sqs.Queue(
            logical_queue_name,
            name=physical_queue_name,
            message_retention_seconds=message_retention_seconds,
            visibility_timeout_seconds=180,
            redrive_policy=self.retry_queue.arn.apply(redrive_policy),
            opts=pulumi.ResourceOptions(
                parent=self,
                delete_before_replace=True,
            ),
        )
        pulumi.export(logical_queue_name, self.queue.id)

        self.register_outputs({})

    # Yes, the `id` property of an SQS queue is actually a URL.
    #
    # The URL generated by Pulumi is currently of the form:
    #     https://sqs.{AWS_REGION}.amazonaws.com/{ACCOUNT_ID}/{QUEUE_NAME}
    #
    # FYI: A URL in the form of:
    #     https://queue.amazonaws.com/{ACCOUNT_ID}/{QUEUE_NAME}
    # would also be valid, but this is not what Pulumi generates.
    #
    # We expose these URLs as properties on ServiceQueue to:
    #
    # a) encapsulate things a bit better
    # b) only have one place that needs to know that "id == URL"
    # c) have one place to modify if this behavior ever changes in Pulumi

    @property
    def main_queue_url(self) -> pulumi.Output[str]:
        return self.queue.id

    @property
    def retry_queue_url(self) -> pulumi.Output[str]:
        return self.retry_queue.id

    @property
    def dead_letter_queue_url(self) -> pulumi.Output[str]:
        return self.dead_letter_queue.id

    @property
    def queue_names(self) -> pulumi.Output[ServiceQueueNames]:
        """
        Helps de-complicate creating dashboards off this service.
        """
        return pulumi.Output.all(
            self._name,
            self.queue.name,
            self.retry_queue.name,
            self.dead_letter_queue.name,
        ).apply(lambda args: ServiceQueueNames(*args))

    def grant_main_queue_consumption_to(self, role: aws.iam.Role) -> None:
        queue_policy.consumption_policy(self.queue, role)

    def grant_retry_queue_consumption_to(self, role: aws.iam.Role) -> None:
        queue_policy.consumption_policy(self.retry_queue, role)

    def grant_dead_letter_queue_consumption_to(self, role: aws.iam.Role) -> None:
        queue_policy.consumption_policy(self.dead_letter_queue, role)

    def grant_main_queue_send_to(self, role: aws.iam.Role) -> None:
        queue_policy.send_policy(self.queue, role)

    def grant_retry_queue_send_to(self, role: aws.iam.Role) -> None:
        queue_policy.send_policy(self.retry_queue, role)

    def grant_dead_letter_queue_send_to(self, role: aws.iam.Role) -> None:
        queue_policy.send_policy(self.dead_letter_queue, role)

    def subscribe_to_emitter(self, emitter: EventEmitter) -> None:
        """
        Enable this queue to be fed by events from `emitter`.
        """
        aws.sns.TopicSubscription(
            f"{self.queue._name}-subscribes-to-{emitter.topic._name}",
            protocol="sqs",
            endpoint=self.queue.arn,
            topic=emitter.topic.arn,
            raw_message_delivery=True,
            opts=pulumi.ResourceOptions(parent=emitter.topic),
        )

        queue_policy.allow_send_from_topic(self.queue, emitter.topic)
